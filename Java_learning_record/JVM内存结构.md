# JVM内存结构

## 程序计数器(寄存器)(Program Counter Register)

用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。

* 使用PC寄存器存储字节码指令地址有什么用呢？ 为什么使用PC寄存器记录当前线程的执行地址呢？
  * 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。
* PC寄存器为什么会被设定为线程私有的？
  * 多线程在一个特定的时间段内只会执行其中某一个线程方法，CPU会不停的做任务切换，这样必然会导致经常中断或恢复。为了能够准确的记录各个线程正在执行的当前字节码指令地址，所以为每个线程都分配了一个PC寄存器，每个线程都独立计算，不会互相影响。

## Java 虚拟机栈(Java Virtual Machine Stacks)

每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的**栈帧(`Stack Frame`），对应着一次次 Java 方法调用**，是**线程私有的**，生命周期和线程一致。

`作用`：主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。

`特点`：
* 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
* JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着入栈（进栈/压栈），方法执行结束出栈
* 栈不存在垃圾回收问题

## 本地方法栈（Native Method Stack）

一个 Native Method 就是一个 Java 调用非 Java 代码的接口。

本地方法栈（Native Method Stack）

* Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用
* 本地方法栈也是线程私有的
* 允许线程固定或者可动态扩展的内存大小
  * 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 `StackOverflowError` 异常
  * 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java虚拟机将会抛出一个`OutofMemoryError`异常
* 本地方法是使用 C 语言实现的
* 它的具体做法是 `Native Method Stack` 中登记 `native` 方法，在 `Execution Engine` 执行时加载本地方法库当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限
* 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区，它甚至可以直接使用本地处理器中的寄存器，直接从本地内存的堆中分配任意数量的内存
* 并不是所有 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果 JVM 产品不打算支持 `native` 方法，也可以无需实现本地方法栈
* **在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一**

_**栈是运行时的单位，而堆是存储的单位。**_

栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。

## 堆内存

**对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。**

**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。**

**为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域（分代的唯一理由就是优化 GC 性能）**

* 新生带（年轻代）：新对象和没达到一定年龄的对象都在新生代
  * 年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 Minor GC。
  * 年轻一代被分为三个部分——伊甸园（`Eden Memory`）和两个幸存区（`Survivor Memory`，被称为`from/t`o或`s0/s1`），默认比例是`8:1:1`
* 老年代（养老区）：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
  * 旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。
  * 通常，垃圾收集是在老年代内存满时执行的。
  * 老年代垃圾收集称为 主GC（Major GC），通常需要更长的时间。
  * 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝
* 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存
  * 不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现
  * 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆）

#### 对象在堆中的生命周期

* 在 JVM 内存模型的堆中，堆被划分为新生代和老年代
  * 新生代又被进一步划分为 `Eden`区 和 `Survivor`区，`Survivor` 区由 `From Survivor` 和 `To Survivor` 组成
* 当创建一个对象时，对象会被优先分配到新生代的 Eden 区
  * 此时 JVM 会给对象定义一个对象年轻计数器（`-XX:MaxTenuringThreshold`）
* 当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（`Minor GC`）
  * JVM 会把存活的对象转移到 `Survivor` 中，并且对象年龄 +1
  * 对象在 `Survivor` 中同样也会经历 `Minor GC`，每经历一次 `Minor GC`，对象年龄都会+1
* 如果分配的对象超过了`-XX:PetenureSizeThreshold`，对象会直接被分配到老年代

## 方法区（Method Area）

  * 方法区（`Method Area`）与 Java 堆一样，是所有线程共享的内存区域
  * 虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开
  * 运行时常量池（`Runtime Constant Pool`）是方法区的一部分。Class 文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项信息是常量池（`Constant Pool Table`），用于存放编译期生成的各种字面量和符号引用，这部分内容将类在加载后进入方法区的运行时常量池中存放。运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的是 `String.intern()`方法。受方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 异常
  * 方法区的大小和堆空间一样，可以选择固定大小也可选择可扩展，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，虚拟机同样会抛出内存溢出错误
  * JVM 关闭后方法区即被释放

![img.png](img.png)

#### **方法区内部结构**

**方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。**

#### 类型信息

对每个加载的类型（类 `class`、接口 `interface`、枚举 `enum`、注解 `annotation`），JVM 必须在方法区中存储以下类型信息
* 这个类型的完整有效名称（全名=包名.类名）
* 这个类型直接父类的完整有效名（对于 `interface`或是 `java.lang.Object`，都没有父类）
* 这个类型的修饰符（`public，abstract，fina`l 的某个子集）
* 这个类型直接接口的一个有序列表
